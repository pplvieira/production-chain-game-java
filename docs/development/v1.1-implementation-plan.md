# Implementation Plan: v1.1.x

## Version Information
- **Target Version**: v1.1.x (All Phases)
- **Planning Date**: 2025-11-18
- **Target Release Date**: TBD (Estimated 3-4 weeks)
- **Developer(s)**: Pedro & Claude
- **Status**: **Planning**

## Version Numbering Scheme

### Format: `v1.1.X`
- **First digit**: Always **1** (major version)
- **Second digit**: Always **1** (for current development cycle)
- **Third digit**: **Increments with EVERY commit** (v1.1.4, v1.1.5, v1.1.6...)

### Phase Completion Markers
- **Phase notation** is added ONLY when a phase is manually marked complete by the developer
- **Format**: `v1.1.X-phaseN` where X is the current commit number
- **Examples**:
  - Working through Phase 1: v1.1.4 → v1.1.5 → v1.1.6 → v1.1.7
  - Phase 1 complete: `v1.1.7-phase1` (developer marks completion)
  - Continue Phase 2: v1.1.8 → v1.1.9 → ... → v1.1.21 → v1.1.22
  - Phase 2 complete: `v1.1.22-phase2` (developer marks completion)

### Phase Targets (Approximate)
- **Phase 1** (Cleanup & Refactoring): Complete when all refactoring done
- **Phase 2** (Core Development): Complete when all features implemented
- **Phase 3** (Testing & QA): Complete when all tests pass
- **Phase 4** (Documentation & Polish): Complete when docs finalized

### Commit Format
**Template**: `<type>: v1.1.X - <description>`

**Examples of regular commits**:
- `feat: v1.1.5 - Add ResourceLoader utility class`
- `fix: v1.1.6 - Correct path resolution in BuildingInstance`
- `refactor: v1.1.8 - Extract constants to ItemConstants class`

**Examples of phase completion commits**:
- `feat: v1.1.7-phase1 - Complete Phase 1: Cleanup & Refactoring`
- `feat: v1.1.22-phase2 - Complete Phase 2: Core Development`

---

## Overview

The idea with this game is to implement a super advanced micromanagement production and trading game in a medieval setting. Implementing super realistic mechanics like:
- A realistic, detailed, and historically accurate resource production trees
- A labor system where workers spend their working hours executing tasks like recipes in production buildings, tending to animals and buildings maintenance, household chores, and transporting of goods
- A free market governed by free trade between player lords and NPCs, where players can exchange goods at monetary or other goods prices set by the every-shifting market
- A very technical, statistical and analytical approach to solving problems and taking decisions
- A weather system and realistic interactions where real world events are simulated and influence mechanics in the gameplay

The idea is to also treat labor hours, money (gold) and some other special resources almost just like every other item. These all can be exchanged, used in recipes and traded equally.

---

## Release Goals

### v1.1.x Focus: Foundation Stabilization
This release focuses on **cleaning up technical debt** and **establishing robust architectural patterns** that will support future development. The goal is to transform the codebase from prototype to production-ready foundation.

#### Primary Objectives
1. **Code Refactoring**: Restructure codebase to industry standards for Java Maven game projects
2. **Deprecation Management**: Make obsolete code inaccessible without deletion (preserve history)
3. **Testing Infrastructure**: Establish comprehensive testing framework
4. **Modular Architecture**: Create flexible, moddable systems for items, recipes, and buildings
5. **Cross-Platform Compatibility**: Remove hardcoded paths, ensure portability

#### Code Quality Principles
- Build incrementally with extensive testing at each step
- Make backend classes future-proof and flexible
- Preserve existing main() test methods while adding proper test suites
- Follow industry best practices for game engine architecture

---

## Key Features

### 1. Code Refactoring & Organization
- Deprecate `datatypesold` package (make inaccessible, don't delete)
- Remove hardcoded Windows paths, use resource loaders
- Add proper logging framework (SLF4J + Logback)
- Extract magic strings to constants classes
- Improve package organization and separation of concerns

### 2. Registry System Redesign
- Create `RegistryManager` for loading from multiple sources (core game + mods)
- Implement immutable registries after initial load
- Support modding through structured registry loading
- Validate and merge registries from base game and mod folders

### 3. Testing Architecture
- Create `src/test/java` directory structure with proper Maven conventions
- Implement unit tests for each major class
- Create `V1_1_IntegrationTest.java` for version-specific integration testing
- Preserve existing `main()` methods for self-contained class tests
- Establish test data folder structure for test JSONs

### 4. Enhanced AdvancedStorage
- Implement category-based whitelist/blacklist for items
- Add degradation rate modifiers per item category (defined at BuildingType level)
- Ensure FIFO ordering respects initial degradation levels
- Support multiple bundles of same item with different degradation states

### 5. Recipe System Foundation
- Add `laborHoursRequired` field to Recipe class
- Implement `RecipeProgress` tracking (turns remaining, ingredients committed, labor committed)
- Create `StateChangeRecipe` subclass for building repairs/upgrades
- Properly track recipe state across multiple turns in BuildingInstance

### 6. Player & Ownership System
- Create `Player` class with basic attributes (ID, name, money)
- Implement building ownership via `List<String> buildingInstanceIds` in Player
- Design with future SQL database schema in mind (N:M relationship table)
- Establish foundation for save/load system with cross-references

### 7. Animal System Completion
- Complete `AnimalBuildingInstance.updateNextTurn()` implementation
- Implement on-demand aggregate statistics calculation
- Individual animal tracking with overview statistics
- Proper food, water, care, and medication requirements

### 8. Test Registry Data
- Add farming/milling items to ItemRegistry
- Create complete production chain recipes (wheat → flour → bread)
- Add corresponding building types for testing
- Populate test data for comprehensive integration testing

---

## Success Criteria

### Technical Success Metrics
- ✅ All code compiles with zero errors and warnings
- ✅ All tests pass (unit + integration) with >70% code coverage
- ✅ Maven build completes successfully on Windows, Mac, and Linux
- ✅ All JSON serialization/deserialization works bidirectionally
- ✅ No hardcoded paths remain in codebase
- ✅ Legacy code properly deprecated and inaccessible

### Functional Success Metrics
- ✅ Can load registries from multiple sources (base + mods)
- ✅ AdvancedStorage correctly handles item degradation with category-specific rates
- ✅ Recipe system tracks multi-turn execution with proper state management
- ✅ Players can own buildings through ID references
- ✅ Animal system calculates statistics on-demand
- ✅ Complete farming production chain executes successfully in tests

### Quality Success Metrics
- ✅ Code follows consistent Java naming conventions
- ✅ All public APIs documented with Javadoc
- ✅ Logging replaces all System.out.println statements
- ✅ No commented-out code blocks >10 lines
- ✅ Architecture supports easy modding and extensibility

---

## Phase 1: Cleanup & Refactoring

### Tasks

#### 1.1 Deprecation & Code Organization
- [ ] Move `com.productionchain.datatypesold` package contents to package-private visibility
- [ ] Add `@Deprecated` annotations to all classes in datatypesold
- [ ] Add warning comments: "DO NOT USE - Legacy code kept for reference only"
- [ ] Verify no active code references datatypesold package
- [ ] Document deprecation in JAVA_FILES_INVENTORY.txt

**Estimated Time**: 2-3 hours

#### 1.2 Path Portability Fix
- [ ] Create `ResourceLoader` utility class in `com.productionchain.utils` package
- [ ] Implement `getResourcePath(String relativePath)` method using ClassLoader
- [ ] Replace all hardcoded paths in:
  - BuildingInstance.java:71
  - AnimalBuildingType.java:94
  - ProductionBuildingType.java:113
- [ ] Test resource loading on different directory structures
- [ ] Update resource paths to use `src/main/resources/` classpath loading

**Estimated Time**: 3-4 hours

#### 1.3 Logging Framework Integration
- [ ] Add SLF4J API and Logback dependencies to pom.xml
- [ ] Create `logback.xml` configuration in `src/main/resources/`
- [ ] Create `Logger` instances in each class (private static final)
- [ ] Replace all `System.out.println()` with appropriate log levels:
  - Debug info → `logger.debug()`
  - Normal operation → `logger.info()`
  - Warnings → `logger.warn()`
  - Errors → `logger.error()`
- [ ] Configure log output format and file rotation
- [ ] Test logging at different levels

**Files affected**: ~8 files with println statements
**Estimated Time**: 4-5 hours

#### 1.4 Constants Extraction
- [ ] Create `com.productionchain.constants` package
- [ ] Create `ItemConstants.java` for hardcoded item names ("Wood", "Stick", etc.)
- [ ] Create `RecipeCategoryConstants.java` for recipe category strings
- [ ] Create `BuildingConstants.java` for building-related constants
- [ ] Create `GameConstants.java` for game-wide constants (turn duration, etc.)
- [ ] Replace all magic strings with constant references
- [ ] Add Javadoc to each constant explaining its purpose

**Estimated Time**: 3-4 hours

#### 1.5 Package Restructuring
- [ ] Create new packages:
  - `com.productionchain.utils` - Utility classes (ResourceLoader, etc.)
  - `com.productionchain.constants` - Constants classes
  - `com.productionchain.service` - Service layer classes (RegistryManager)
  - `com.productionchain.exceptions` - Custom exceptions
- [ ] Move appropriate classes to new packages
- [ ] Update imports across codebase
- [ ] Verify compilation after restructuring

**Estimated Time**: 2-3 hours

### Phase 1 Dependencies
- None (foundational work)

### Phase 1 Estimated Total Time
**18-22 hours (2.5-3 days)**

---

## Phase 2: Core Development

### Tasks

#### 2.1 Registry System Redesign
- [ ] Design `RegistryManager` class architecture
- [ ] Implement `RegistrySource` interface (for base game + mod loading)
- [ ] Create immutable wrapper classes for registries:
  - `ImmutableItemRegistry`
  - `ImmutableRecipeRegistry`
  - `ImmutableAnimalTypeRegistry`
- [ ] Implement registry loading pipeline:
  1. Load base game registries from `src/main/resources/`
  2. Scan for mods in `mods/` folder
  3. Validate mod JSONs
  4. Merge registries with conflict resolution
  5. Create immutable instances
- [ ] Add `RegistryManager.lock()` to prevent runtime modifications
- [ ] Preserve `addItem()` methods but deprecate for gameplay use (dev/testing only)

**Estimated Time**: 8-10 hours

#### 2.2 Enhanced AdvancedStorage Implementation
- [ ] Add fields to AdvancedStorage:
  - `List<String> allowedItemCategories` (whitelist)
  - `List<String> blockedItemCategories` (blacklist)
  - `Map<String, Double> degradationRateModifiers` (category → multiplier)
- [ ] Add to BuildingType:
  - `Map<String, Double> storageDegradationModifiers`
  - Pass to BuildingInstance on creation
- [ ] Implement `canAddItem(ItemType item)` validation:
  - Check whitelist (if not empty, item category must be in list)
  - Check blacklist (item category must NOT be in list)
  - Return boolean result
- [ ] Update `addItem()` to check `canAddItem()` before adding
- [ ] Implement category-specific degradation in `degradeItems()`:
  - For each item batch, get item category
  - Get modifier from `degradationRateModifiers` (default 1.0)
  - Apply: `newDurability = currentDurability - (itemDegradationRate * modifier)`
- [ ] Ensure FIFO respects initial degradation (sort on insertion)
- [ ] Add comprehensive Javadoc

**Estimated Time**: 6-8 hours

#### 2.3 Recipe System Enhancement
- [ ] Add `laborHoursRequired` field to Recipe class
- [ ] Create `RecipeProgress` inner class in BuildingInstance:
  ```java
  private static class RecipeProgress {
      Recipe recipe;
      int turnsRemaining;
      Map<String, Double> ingredientsCommitted;
      double laborCommitted;
  }
  ```
- [ ] Replace `Recipe activeRecipe` with `RecipeProgress currentRecipe` in BuildingInstance
- [ ] Update `performRecipe()` to:
  - Initialize RecipeProgress on first call
  - Track ingredients consumed per turn
  - Track labor hours consumed per turn
  - Decrement turnsRemaining
  - Complete recipe when turnsRemaining == 0
- [ ] Create `StateChangeRecipe` subclass:
  - Extends Recipe
  - Add `Function<BuildingInstance, Void> stateChangeFunction` field
  - Override `execute()` to apply state change
  - Use for repairs: `(building) -> building.setCondition(100.0)`
  - Use for upgrades: `(building) -> building.addUpgrade(upgradeType)`

**Estimated Time**: 8-10 hours

#### 2.4 Player & Ownership System
- [ ] Create `Player` class in `com.productionchain.entities`:
  ```java
  public class Player {
      private String playerId;
      private String name;
      private double money;
      private List<String> buildingInstanceIds;
      // Future: private List<String> animalInstanceIds;
  }
  ```
- [ ] Add JSON serialization annotations
- [ ] Create `PlayerRegistry` for managing players
- [ ] Update BuildingInstance:
  - Keep `String owner` field (for now this is playerId)
  - Document future migration to pure ID-based system
- [ ] Design database schema (document for future):
  ```sql
  -- Future SQL schema design
  CREATE TABLE players (
      player_id VARCHAR(36) PRIMARY KEY,
      name VARCHAR(255),
      money DECIMAL(10,2)
  );

  CREATE TABLE building_instances (
      building_id VARCHAR(36) PRIMARY KEY,
      type_name VARCHAR(255),
      x INT,
      y INT,
      condition DECIMAL(5,2)
  );

  CREATE TABLE player_buildings (
      player_id VARCHAR(36),
      building_id VARCHAR(36),
      PRIMARY KEY (player_id, building_id),
      FOREIGN KEY (player_id) REFERENCES players(player_id),
      FOREIGN KEY (building_id) REFERENCES building_instances(building_id)
  );
  ```
- [ ] Implement save/load for Players with building ID references

**Estimated Time**: 5-6 hours

#### 2.5 Animal System Completion
- [ ] Implement `AnimalBuildingInstance.updateNextTurn()`:
  - Age all animals (+1 per turn)
  - Update health based on food/water availability
  - Check for deaths (age > lifespan or health <= 0)
  - Update satisfaction based on conditions
  - Process reproduction if conditions met
- [ ] Implement aggregate statistics (on-demand calculation):
  - `getAverageAge()`
  - `getAverageHealth()`
  - `getAverageSatisfaction()`
  - `getHealthDistribution()` → Map<HealthRange, Integer>
  - `getAgeDistribution()` → Map<AgeRange, Integer>
- [ ] Add food/water consumption per turn
- [ ] Add care and medication requirements
- [ ] Document individual vs. aggregate tracking in Javadoc

**Estimated Time**: 6-8 hours

### Phase 2 Dependencies
- Phase 1 must be complete (clean codebase foundation)

### Phase 2 Estimated Total Time
**33-42 hours (5-6 days)**

---

## Phase 3: Testing & Quality Assurance

### Tasks

#### 3.1 Test Infrastructure Setup
- [ ] Create directory structure:
  ```
  src/test/java/com/productionchain/
  ├── buildings/
  ├── mechanics/
  ├── enginedatatypes/
  ├── service/
  └── integration/
  ```
- [ ] Create `test-data/` folder in project root:
  ```
  test-data/
  ├── registries/
  │   ├── items-test.json
  │   ├── recipes-test.json
  │   └── buildings-test.json
  └── scenarios/
      └── farming-chain-test/
  ```
- [ ] Configure Maven Surefire plugin for test execution
- [ ] Add JUnit 5 (Jupiter) dependency (upgrade from JUnit 4)
- [ ] Add AssertJ for fluent assertions
- [ ] Add Mockito for mocking

**Estimated Time**: 2-3 hours

#### 3.2 Unit Tests - Core Classes
- [ ] **ItemTypeTest.java**
  - Test constructor and getters
  - Test JSON serialization/deserialization
  - Test equals/hashCode
- [ ] **RecipeTest.java**
  - Test ingredient validation
  - Test labor hours calculation
  - Test JSON serialization
- [ ] **AdvancedStorageTest.java**
  - Test item addition with capacity limits
  - Test FIFO removal
  - Test degradation with category modifiers
  - Test whitelist/blacklist validation
  - Test spoilage removal
- [ ] **RecipeProgressTest.java**
  - Test progress tracking
  - Test ingredient commitment
  - Test labor commitment
  - Test completion detection

**Estimated Time**: 8-10 hours

#### 3.3 Unit Tests - Building System
- [ ] **BuildingTypeTest.java**
  - Test polymorphic JSON deserialization
  - Test recipe category filtering
- [ ] **BuildingInstanceTest.java**
  - Test recipe execution
  - Test storage integration
  - Test condition tracking
- [ ] **StateChangeRecipeTest.java**
  - Test repair functionality
  - Test upgrade application
  - Test state change execution

**Estimated Time**: 6-8 hours

#### 3.4 Unit Tests - Registry System
- [ ] **RegistryManagerTest.java**
  - Test base game loading
  - Test mod loading and merging
  - Test conflict resolution
  - Test immutability after lock
  - Test validation of mod JSONs
- [ ] **ItemRegistryTest.java**
  - Test item lookup by name
  - Test category filtering
  - Test JSON persistence
- [ ] **RecipeRegistryTest.java**
  - Test recipe lookup
  - Test category filtering

**Estimated Time**: 6-8 hours

#### 3.5 Unit Tests - Player & Animal Systems
- [ ] **PlayerTest.java**
  - Test building ownership tracking
  - Test money transactions
  - Test JSON serialization
- [ ] **AnimalInstanceTest.java**
  - Test lifecycle (aging, death)
  - Test health updates
  - Test reproduction
- [ ] **AnimalBuildingInstanceTest.java**
  - Test aggregate statistics
  - Test food/water consumption
  - Test turn updates

**Estimated Time**: 5-6 hours

#### 3.6 Integration Tests
- [ ] **V1_1_IntegrationTest.java**
  - Test complete registry loading pipeline
  - Test building creation and ownership
  - Test recipe execution across multiple turns
  - Test storage degradation over time
  - Test animal lifecycle simulation
  - Test complete farming chain (wheat → flour → bread):
    1. Create Farm building, plant wheat
    2. Execute "Grow Wheat" recipe over multiple turns
    3. Harvest wheat to storage
    4. Transfer wheat to Mill building
    5. Execute "Mill Flour" recipe
    6. Transfer flour to Bakery building
    7. Execute "Bake Bread" recipe
    8. Verify final output
    9. Verify item degradation throughout chain
  - Test player creation and building acquisition
  - Test mod loading and registry merging
  - Test save/load complete game state

**Estimated Time**: 10-12 hours

#### 3.7 Test Data Creation
- [ ] Create comprehensive test registries in `test-data/registries/`:
  - **items-test.json**: Wheat, Flour, Bread, Wood, Tools, Water
  - **recipes-test.json**:
    - Plant Wheat (1 Wheat Seed → 1 Planted Field, 2 turns, 4 labor hours)
    - Grow Wheat (1 Planted Field → 10 Wheat, 20 turns, 1 labor hour/turn)
    - Mill Flour (10 Wheat → 8 Flour, 2 turns, 3 labor hours)
    - Bake Bread (5 Flour + 1 Water → 8 Bread, 3 turns, 5 labor hours)
    - Repair Building (5 Wood → Repair, 1 turn, 2 labor hours, StateChange)
  - **buildings-test.json**:
    - Farm (can run: Basic farming category)
    - Mill (can run: Basic milling category)
    - Bakery (can run: Basic baking category)
- [ ] Create test scenarios in `test-data/scenarios/`
- [ ] Document test data structure

**Estimated Time**: 4-5 hours

#### 3.8 Manual Testing & Validation
- [ ] Run all existing main() tests, verify they still work
- [ ] Execute full test suite: `mvn clean test`
- [ ] Run integration tests with verbose logging
- [ ] Test on Windows, Mac, and Linux (if possible)
- [ ] Validate JSON files with python json.tool
- [ ] Check test coverage report (aim for >70%)
- [ ] Document any test failures and fixes

**Estimated Time**: 4-6 hours

### Phase 3 Dependencies
- Phase 2 must be complete (all features implemented)

### Phase 3 Estimated Total Time
**45-58 hours (6-8 days)**

---

## Phase 4: Documentation & Polish

### Tasks

#### 4.1 Code Documentation
- [ ] Add Javadoc to all public classes:
  - Class-level: purpose, usage examples, @since v1.1.x
  - Method-level: @param, @return, @throws
  - Field-level: explain purpose
- [ ] Generate Javadoc HTML: `mvn javadoc:javadoc`
- [ ] Review generated docs for completeness
- [ ] Add package-info.java to each package explaining purpose

**Estimated Time**: 6-8 hours

#### 4.2 Update Architecture Documentation
- [ ] Update `docs/architecture/CODEBASE_ANALYSIS.md`:
  - Document new package structure
  - Document RegistryManager architecture
  - Document Player ownership system
  - Update class interaction diagrams
- [ ] Update `docs/development/JAVA_FILES_INVENTORY.txt`:
  - Add new classes (RegistryManager, Player, StateChangeRecipe, etc.)
  - Update line counts
  - Document deprecations
- [ ] Create new diagram: Registry loading pipeline
- [ ] Create new diagram: Recipe execution state machine

**Estimated Time**: 4-5 hours

#### 4.3 Testing Documentation
- [ ] Document testing approach in `docs/development/TESTING_GUIDE.md`:
  - How to run tests
  - How to write new tests
  - Test data structure
  - Coverage expectations
- [ ] Document test scenarios
- [ ] Create testing checklist template

**Estimated Time**: 2-3 hours

#### 4.4 Developer Guide Updates
- [ ] Update `docs/README.md` with v1.1.x changes
- [ ] Create "Adding a Mod" guide in `docs/development/MODDING_GUIDE.md`:
  - Mod folder structure
  - JSON format requirements
  - How registries merge
  - Conflict resolution rules
- [ ] Update Quick Reference with new APIs
- [ ] Document migration path from v1.0 to v1.1

**Estimated Time**: 3-4 hours

#### 4.5 Code Cleanup & Linting
- [ ] Remove all unused imports
- [ ] Remove commented-out code blocks
- [ ] Ensure consistent code formatting (use IDE formatter)
- [ ] Fix all compiler warnings
- [ ] Run static analysis (if available)
- [ ] Verify no TODOs remain untracked

**Estimated Time**: 2-3 hours

#### 4.6 Release Notes & Changelog
- [ ] Create detailed changelog for v1.1.x
- [ ] Document breaking changes (if any)
- [ ] Document new features
- [ ] Document deprecated features
- [ ] Create migration guide from v1.0.x
- [ ] Update main README.md

**Estimated Time**: 2-3 hours

### Phase 4 Dependencies
- Phase 3 must be complete (all tests passing)

### Phase 4 Estimated Total Time
**19-26 hours (3-4 days)**

---

## Technical Specifications

### Architecture Changes

#### New Package Structure
```
com.productionchain/
├── buildings/          (existing - no changes)
├── mechanics/          (existing - enhanced)
├── enginedatatypes/    (existing - enhanced)
├── datatypesold/       (deprecated - package-private)
├── entities/           (NEW - Player, future: NPC, Settlement)
├── service/            (NEW - RegistryManager, GameEngine)
├── utils/              (NEW - ResourceLoader, ValidationUtils)
├── constants/          (NEW - ItemConstants, RecipeConstants, etc.)
└── exceptions/         (NEW - RegistryException, RecipeException, etc.)
```

#### Registry System Architecture
```
RegistryManager
├── loadBaseRegistries()
│   ├── ItemRegistry (immutable after load)
│   ├── RecipeRegistry (immutable after load)
│   └── AnimalTypeRegistry (immutable after load)
├── loadMods()
│   ├── Scan mods/ folder
│   ├── Validate mod JSONs
│   └── Merge with base registries
├── lock()
│   └── Prevent runtime modifications
└── getRegistry(Class<T> type)
```

#### Recipe Execution State Machine
```
IDLE → STARTED → IN_PROGRESS → COMPLETED
  ↓        ↓           ↓            ↓
  ↓        ↓       PAUSED ←---------↓
  ↓        ↓           ↓
  ↓        ↓→ FAILED ←-↓
  ↓
  └→ CANCELLED

States:
- IDLE: No active recipe
- STARTED: Recipe set, ingredients being committed (turn 1)
- IN_PROGRESS: Recipe executing (turns 2..N-1)
- COMPLETED: Recipe finished, outputs produced
- PAUSED: Recipe paused (future feature)
- FAILED: Recipe failed (insufficient resources)
- CANCELLED: Recipe manually cancelled
```

### New Components

#### Core Classes
- **`RegistryManager`** (`com.productionchain.service`)
  - Manages loading and merging of all registries
  - Implements mod support
  - Provides immutable registry access after initialization

- **`Player`** (`com.productionchain.entities`)
  - Represents a player/lord in the game
  - Tracks owned buildings via IDs
  - Manages money and resources

- **`StateChangeRecipe`** (`com.productionchain.enginedatatypes`)
  - Extends Recipe
  - Executes state changes on buildings (repair, upgrade)
  - Uses functional interface for flexibility

- **`RecipeProgress`** (inner class in `BuildingInstance`)
  - Tracks recipe execution state
  - Records committed ingredients and labor
  - Manages multi-turn recipe progression

#### Utility Classes
- **`ResourceLoader`** (`com.productionchain.utils`)
  - Loads resources from classpath
  - Handles cross-platform path resolution

- **`ValidationUtils`** (`com.productionchain.utils`)
  - Validates JSON structures
  - Validates game object constraints

- **`StringUtils`** (`com.productionchain.utils`)
  - String manipulation helpers
  - ID generation utilities

#### Constants Classes
- **`ItemConstants`** - Item names ("WOOD", "WHEAT", etc.)
- **`RecipeCategoryConstants`** - Recipe categories ("BASIC_FARMING", etc.)
- **`BuildingConstants`** - Building-related constants
- **`GameConstants`** - Game-wide configuration (turn duration, etc.)

#### Exception Classes
- **`RegistryException`** - Registry loading/validation errors
- **`RecipeExecutionException`** - Recipe execution failures
- **`StorageException`** - Storage capacity/validation errors
- **`InvalidModException`** - Mod loading errors

### Modified Components

#### Enhanced Components
- **`AdvancedStorage`**
  - Add: `allowedItemCategories`, `blockedItemCategories`
  - Add: `degradationRateModifiers` (category → multiplier)
  - Add: `canAddItem(ItemType)` validation
  - Modify: `degradeItems()` to use category-specific rates

- **`Recipe`**
  - Add: `laborHoursRequired` field
  - Add: JSON serialization for new field

- **`BuildingInstance`**
  - Replace: `Recipe activeRecipe` with `RecipeProgress currentRecipe`
  - Modify: `performRecipe()` for multi-turn tracking
  - Add: `commitIngredients()`, `commitLabor()` methods

- **`BuildingType`**
  - Add: `Map<String, Double> storageDegradationModifiers`
  - Pass modifiers to BuildingInstance on creation

- **`AnimalBuildingInstance`**
  - Implement: `updateNextTurn()` (complete lifecycle)
  - Add: Aggregate statistics methods (on-demand calculation)
  - Add: Food/water consumption tracking

#### Deprecated Components
- **`com.productionchain.datatypesold.*`** (all classes)
  - Mark: `@Deprecated` with warning message
  - Change: Package visibility to package-private
  - Keep: For historical reference only

### Dependencies

#### New Maven Dependencies
```xml
<!-- Logging -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>2.0.9</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.4.11</version>
</dependency>

<!-- Testing (upgrade from JUnit 4) -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.10.0</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.assertj</groupId>
    <artifactId>assertj-core</artifactId>
    <version>3.24.2</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.5.0</version>
    <scope>test</scope>
</dependency>
```

#### Existing Dependencies (keep)
- Jackson 2.17.0 (JSON serialization)
- Maven compiler, resources, surefire plugins

---

## Testing Strategy

### Unit Testing Approach

#### Test Structure
- One test class per production class
- Test naming: `<ClassName>Test.java`
- Test methods: `testMethodName_Scenario_ExpectedResult()`
- Use Given-When-Then pattern in test comments

#### Coverage Goals
- **Line Coverage**: >70% (aiming for 85%)
- **Branch Coverage**: >60%
- **Method Coverage**: 100% (all public methods)

#### Test Data Management
- Store test JSONs in `test-data/registries/`
- Use `@TempDir` for temporary test files
- Clean up resources in `@AfterEach` methods
- Use test constants (avoid magic values)

### Integration Testing Approach

#### Version-Specific Integration Tests
- **V1_1_IntegrationTest.java**: Tests all v1.1.0 features together
- Tests complete workflows end-to-end
- Validates cross-component interactions
- Tests persistence (save/load cycles)

#### Integration Test Scenarios
1. **Complete Production Chain**
   - Load all registries
   - Create buildings
   - Execute multi-step recipes
   - Verify item flow through system
   - Test degradation over time

2. **Player Ownership**
   - Create player
   - Assign buildings to player
   - Save player state
   - Load player state
   - Verify building associations

3. **Mod Loading**
   - Load base registries
   - Load test mod
   - Verify registry merging
   - Test conflict resolution
   - Verify immutability after load

4. **Animal Lifecycle**
   - Create animal building
   - Add animals
   - Simulate multiple turns
   - Verify aging, health, satisfaction
   - Test reproduction and death
   - Validate statistics

### Manual Testing Checklist

#### Pre-Deployment Validation
- [ ] Run all unit tests: `mvn clean test`
- [ ] Run integration tests with verbose output
- [ ] Execute all `main()` methods in classes (verify they still work)
- [ ] Test on Windows (if available)
- [ ] Test on Linux
- [ ] Test on Mac (if available)
- [ ] Validate all JSON files: `python3 -m json.tool <file>`
- [ ] Check for hardcoded paths: `grep -r "C:\\\\" src/`
- [ ] Verify logging output at different levels
- [ ] Test mod loading with sample mod
- [ ] Run complete farming chain scenario manually
- [ ] Verify save/load preserves all data
- [ ] Check Maven package builds: `mvn package`
- [ ] Test JAR execution (if main class configured)

#### Performance Testing
- [ ] Test registry loading time (<1 second for base game)
- [ ] Test mod loading time (<5 seconds for 10 mods)
- [ ] Test recipe execution time (<1ms per turn)
- [ ] Test storage degradation time (<10ms for 1000 items)
- [ ] Test animal statistics calculation (<5ms for 100 animals)

---

## Known Issues & Risks

### Technical Risks

#### 1. Registry Immutability vs. Modding Flexibility
**Risk**: Making registries immutable after load may conflict with hot-reloading mods.
**Severity**: Medium
**Impact**: May need to restart game to load new mods

#### 2. Recipe Multi-Turn State Persistence
**Risk**: Complex state tracking across turns may introduce bugs in save/load.
**Severity**: Medium
**Impact**: Could lose recipe progress on reload

#### 3. FIFO Ordering with Degradation
**Risk**: Maintaining FIFO order while respecting initial degradation levels is complex.
**Severity**: Low
**Impact**: Items may not degrade in exactly expected order

#### 4. Performance with Large Registries
**Risk**: Loading and merging thousands of modded items may be slow.
**Severity**: Low
**Impact**: Longer game startup time

#### 5. Backwards Compatibility
**Risk**: Changes to JSON structure may break existing saved games.
**Severity**: High
**Impact**: Players lose progress

#### 6. Test Coverage on Edge Cases
**Risk**: May not catch all edge cases in storage/recipe systems.
**Severity**: Medium
**Impact**: Runtime bugs in production

### Mitigation Strategies

#### For Registry Immutability (Risk #1)
- **Strategy**: Implement `RegistryManager.reload()` for development mode
- Document that production mode requires restart for mod changes
- Add dev flag to enable hot-reloading with performance warning
- Consider lazy-loading registries in future versions

#### For Recipe State Persistence (Risk #2)
- **Strategy**: Create comprehensive serialization tests
- Implement `RecipeProgress.toJson()` and `fromJson()` with validation
- Add migration tests from v1.0 to v1.1 save format
- Document save format versioning strategy
- Consider adding save format version field to JSON

#### For FIFO Degradation (Risk #3)
- **Strategy**: Implement robust sorting algorithm
- Add extensive unit tests for edge cases
- Document exact ordering behavior in Javadoc
- Consider using priority queue if needed
- Add validation to ensure consistency

#### For Performance (Risk #4)
- **Strategy**: Implement lazy loading for registries
- Add caching for frequently accessed items
- Profile registry loading with JMeter
- Add progress indicators for loading
- Consider background loading in future

#### For Backwards Compatibility (Risk #5)
- **Strategy**: Add save format version field to all JSON files
- Implement save format migration system
- Create automated migration tests
- Document breaking changes clearly
- Keep old deserialization code for migration period
- Add deprecation warnings before removing old formats

#### For Test Coverage (Risk #6)
- **Strategy**: Aim for >70% code coverage
- Use mutation testing (PIT) to verify test quality
- Add property-based testing for complex algorithms
- Peer review test cases
- Document known untested edge cases
- Create issue tickets for future test additions

---

## Timeline

| Phase | Tasks | Start Date | End Date | Estimated Hours | Status |
|-------|-------|------------|----------|-----------------|--------|
| **Phase 1: Cleanup** | Commits: v1.1.X → vX.X.X-phase1 | TBD | TBD | 18-22 hours | Planning |
| 1.1 Deprecation | Package-private datatypesold | TBD | TBD | 2-3 hours | Pending |
| 1.2 Path Fix | Resource loader implementation | TBD | TBD | 3-4 hours | Pending |
| 1.3 Logging | SLF4J integration | TBD | TBD | 4-5 hours | Pending |
| 1.4 Constants | Extract magic strings | TBD | TBD | 3-4 hours | Pending |
| 1.5 Restructure | Package organization | TBD | TBD | 2-3 hours | Pending |
| **Phase 2: Core Dev** | Commits: continuing → vX.X.X-phase2 | TBD | TBD | 33-42 hours | Planning |
| 2.1 Registries | RegistryManager system | TBD | TBD | 8-10 hours | Pending |
| 2.2 Storage | Enhanced AdvancedStorage | TBD | TBD | 6-8 hours | Pending |
| 2.3 Recipes | Multi-turn tracking | TBD | TBD | 8-10 hours | Pending |
| 2.4 Player | Ownership system | TBD | TBD | 5-6 hours | Pending |
| 2.5 Animals | Complete lifecycle | TBD | TBD | 6-8 hours | Pending |
| **Phase 3: Testing** | Commits: continuing → vX.X.X-phase3 | TBD | TBD | 45-58 hours | Planning |
| 3.1 Setup | Test infrastructure | TBD | TBD | 2-3 hours | Pending |
| 3.2 Core Tests | Unit tests for core | TBD | TBD | 8-10 hours | Pending |
| 3.3 Building Tests | Unit tests for buildings | TBD | TBD | 6-8 hours | Pending |
| 3.4 Registry Tests | Unit tests for registries | TBD | TBD | 6-8 hours | Pending |
| 3.5 Entity Tests | Player & Animal tests | TBD | TBD | 5-6 hours | Pending |
| 3.6 Integration | V1_1_IntegrationTest | TBD | TBD | 10-12 hours | Pending |
| 3.7 Test Data | Create test registries | TBD | TBD | 4-5 hours | Pending |
| 3.8 Manual | Manual validation | TBD | TBD | 4-6 hours | Pending |
| **Phase 4: Docs** | Commits: continuing → vX.X.X-phase4 | TBD | TBD | 19-26 hours | Planning |
| 4.1 Javadoc | Code documentation | TBD | TBD | 6-8 hours | Pending |
| 4.2 Architecture | Update architecture docs | TBD | TBD | 4-5 hours | Pending |
| 4.3 Testing Docs | Testing guide | TBD | TBD | 2-3 hours | Pending |
| 4.4 Dev Guides | Modding & migration guides | TBD | TBD | 3-4 hours | Pending |
| 4.5 Cleanup | Code linting | TBD | TBD | 2-3 hours | Pending |
| 4.6 Release Notes | Changelog & migration | TBD | TBD | 2-3 hours | Pending |

### Total Estimated Time
**115-148 hours (14.5-18.5 days of work)**

### Realistic Timeline
Assuming ~6 hours productive work per day:
- **Optimistic**: 20 days (3 weeks)
- **Realistic**: 25 days (3.5 weeks)
- **Pessimistic**: 30 days (4.5 weeks)

**Recommended Target**: **3-4 weeks** with buffer for unexpected issues

---

## Notes & Decisions

### Design Decisions

#### 1. Registry Mutability Approach
**Decision**: Use `RegistryManager` with immutable registries after load
**Rationale**:
- Prevents accidental modifications during gameplay
- Enables safe multi-threaded access in future
- Supports structured mod loading with validation
- Maintains developer flexibility with deprecated add methods
**Trade-offs**:
- More complex initial setup
- Requires game restart for mod changes (acceptable for v1.1)

#### 2. Recipe State Tracking
**Decision**: Create `RecipeProgress` inner class with full state tracking
**Rationale**:
- Encapsulates recipe execution state
- Enables proper save/load of in-progress recipes
- Supports future features (pause, cancel, modify recipes mid-execution)
- Clear separation between recipe definition and execution state
**Trade-offs**:
- More complex than simple turn counter
- Larger save file size

#### 3. Labor as Separate Field
**Decision**: Add `laborHoursRequired` to Recipe, not as Item
**Rationale**:
- Labor generation mechanics differ from item production
- Simplifies initial implementation
- Easier for UI to display separately
- Can migrate to resource abstraction later if needed
**Future**: May create `Resource` superclass for Items, Labor, Money

#### 4. Player Building Ownership
**Decision**: Store `List<String> buildingInstanceIds` in Player
**Rationale**:
- Simple to implement
- Easy to serialize to JSON
- Prepares for future SQL migration (N:M table)
- Avoids circular references in JSON
**Future Migration Path**: Document SQL schema for future database implementation

#### 5. Deprecation Instead of Deletion
**Decision**: Keep `datatypesold` package but make package-private
**Rationale**:
- Preserves development history
- Allows comparison between old/new implementations
- Can reference if migration issues arise
- Prevents accidental use via reduced visibility
**Maintenance**: Mark for potential deletion in v2.0.0

#### 6. Test Data Location
**Decision**: Create `test-data/` folder in project root
**Rationale**:
- Keeps test files separate from production resources
- Easier to exclude from final JAR
- Can include large test scenarios without bloating classpath
- Standard practice for game projects
**Alternative Considered**: `src/test/resources/` - rejected as too cluttered

#### 7. FIFO with Degradation Levels
**Decision**: Sort item batches by current degradation on insertion
**Rationale**:
- Ensures most-degraded items used first (realistic)
- Simple to implement with Comparator
- Maintains FIFO for items added with same degradation
**Trade-off**: Small performance cost on insertion

#### 8. Animal Statistics Calculation
**Decision**: Calculate on-demand, don't cache
**Rationale**:
- Simpler implementation
- No risk of stale cached data
- Performance acceptable for expected animal counts (<1000 per building)
- Can optimize later if needed with caching
**Future**: Add caching if performance issues arise

### Implementation Notes

#### JSON Compatibility
- All new fields must have default values for backwards compatibility
- Add `@JsonProperty(defaultValue = "...")` where appropriate
- Document breaking changes in changelog
- Test loading old JSON format with new code

#### Testing Philosophy
- Write tests first for critical components (TDD for registry system)
- Keep main() methods for quick manual testing
- Integration tests validate happy path and common scenarios
- Unit tests cover edge cases and error conditions

#### Logging Levels
- **TRACE**: Detailed flow through system (disabled in production)
- **DEBUG**: Useful for development (variable values, state changes)
- **INFO**: Important events (registry loaded, building created, recipe completed)
- **WARN**: Unexpected but handled situations (missing optional field)
- **ERROR**: Failures that prevent operation (JSON parse error)

#### Code Style Conventions
- Use Java naming conventions (camelCase, PascalCase)
- Max line length: 120 characters
- Use meaningful variable names (no single letters except loop counters)
- Group related methods together
- Order: fields → constructors → public methods → private methods

### Changes from Original Plan

*This section will be updated during implementation to track deviations*

### Lessons Learned

*This section will be completed after v1.1.0 release*

---

## Related Documentation

- [Important all purpose development documentation](../README.md)
- [Architecture Documentation](../architecture/)
- [Codebase Analysis](../architecture/CODEBASE_ANALYSIS.md)
- [Java Files Inventory](./JAVA_FILES_INVENTORY.txt)
- [Quick Reference Guide](../architecture/QUICK_REFERENCE.md)
- [Deployment Guide](../deployment/)
- [Testing Protocol](../README.md#-testing-before-deployment)

---

## Appendix A: Test Data Specifications

### Test Registry: items-test.json
```json
{
  "items": [
    {
      "name": "Wheat",
      "category": "Crop",
      "weight": 0.1,
      "baseStorageSpace": 0.05,
      "baseDurability": 30.0,
      "degradationRate": 0.5,
      "canTrade": true,
      "canTransport": true
    },
    {
      "name": "Flour",
      "category": "Processed Food",
      "weight": 0.08,
      "baseStorageSpace": 0.04,
      "baseDurability": 60.0,
      "degradationRate": 0.2,
      "canTrade": true,
      "canTransport": true
    },
    {
      "name": "Bread",
      "category": "Prepared Food",
      "weight": 0.2,
      "baseStorageSpace": 0.1,
      "baseDurability": 15.0,
      "degradationRate": 1.0,
      "canTrade": true,
      "canTransport": true
    },
    {
      "name": "Water",
      "category": "Liquid",
      "weight": 1.0,
      "baseStorageSpace": 0.5,
      "baseDurability": 999.0,
      "degradationRate": 0.0,
      "canTrade": false,
      "canTransport": true
    },
    {
      "name": "Wood",
      "category": "Raw Material",
      "weight": 5.0,
      "baseStorageSpace": 1.0,
      "baseDurability": 999.0,
      "degradationRate": 0.05,
      "canTrade": true,
      "canTransport": true
    }
  ]
}
```

### Test Registry: recipes-test.json
```json
{
  "recipes": [
    {
      "name": "Grow Wheat",
      "category": "Basic farming",
      "description": "Cultivate wheat over growing season",
      "complexity": 2,
      "duration": 20,
      "inputs": {"items": [{"itemName": "Wheat Seed", "quantity": 1}]},
      "outputs": {"items": [{"itemName": "Wheat", "quantity": 10}]},
      "laborHoursRequired": 20.0,
      "enabled": true
    },
    {
      "name": "Mill Flour",
      "category": "Basic milling",
      "description": "Grind wheat into flour",
      "complexity": 1,
      "duration": 2,
      "inputs": {"items": [{"itemName": "Wheat", "quantity": 10}]},
      "outputs": {"items": [{"itemName": "Flour", "quantity": 8}]},
      "laborHoursRequired": 3.0,
      "enabled": true
    },
    {
      "name": "Bake Bread",
      "category": "Basic baking",
      "description": "Bake bread from flour and water",
      "complexity": 2,
      "duration": 3,
      "inputs": {
        "items": [
          {"itemName": "Flour", "quantity": 5},
          {"itemName": "Water", "quantity": 1}
        ]
      },
      "outputs": {"items": [{"itemName": "Bread", "quantity": 8}]},
      "laborHoursRequired": 5.0,
      "enabled": true
    },
    {
      "name": "Repair Building",
      "category": "Maintenance",
      "description": "Repair building to full condition",
      "complexity": 1,
      "duration": 1,
      "inputs": {"items": [{"itemName": "Wood", "quantity": 5}]},
      "outputs": {"items": []},
      "laborHoursRequired": 2.0,
      "enabled": true,
      "recipeType": "StateChange",
      "stateChangeType": "Repair"
    }
  ]
}
```

### Test Registry: buildings-test.json
```json
{
  "buildings": [
    {
      "type": "ProductionBuildingType",
      "name": "Farm",
      "category": "Agriculture",
      "description": "Basic farm for growing crops",
      "baseEfficiency": 1.0,
      "baseDegradationRate": 0.1,
      "recipeHandler": {
        "baseNumOperations": 1,
        "baseRecipeCategories": ["Basic farming"]
      },
      "storageDegradationModifiers": {
        "Crop": 0.8,
        "Processed Food": 1.0,
        "Prepared Food": 1.2
      }
    },
    {
      "type": "ProductionBuildingType",
      "name": "Mill",
      "category": "Processing",
      "description": "Mill for processing grain",
      "baseEfficiency": 1.0,
      "baseDegradationRate": 0.15,
      "recipeHandler": {
        "baseNumOperations": 2,
        "baseRecipeCategories": ["Basic milling"]
      },
      "storageDegradationModifiers": {
        "Crop": 0.9,
        "Processed Food": 0.7
      }
    },
    {
      "type": "ProductionBuildingType",
      "name": "Bakery",
      "category": "Crafting",
      "description": "Bakery for preparing bread",
      "baseEfficiency": 1.0,
      "baseDegradationRate": 0.2,
      "recipeHandler": {
        "baseNumOperations": 3,
        "baseRecipeCategories": ["Basic baking"]
      },
      "storageDegradationModifiers": {
        "Prepared Food": 0.8,
        "Processed Food": 0.9
      }
    }
  ]
}
```

---

## Appendix B: SQL Schema (Future Reference)

```sql
-- Players table
CREATE TABLE players (
    player_id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    money DECIMAL(12,2) DEFAULT 0.00,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Building instances table
CREATE TABLE building_instances (
    building_id VARCHAR(36) PRIMARY KEY,
    type_name VARCHAR(255) NOT NULL,
    x INT NOT NULL,
    y INT NOT NULL,
    condition_percentage DECIMAL(5,2) DEFAULT 100.00,
    storage_data JSON,
    active_recipe_data JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Player-Building ownership (N:M relationship)
CREATE TABLE player_buildings (
    player_id VARCHAR(36) NOT NULL,
    building_id VARCHAR(36) NOT NULL,
    acquired_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (player_id, building_id),
    FOREIGN KEY (player_id) REFERENCES players(player_id) ON DELETE CASCADE,
    FOREIGN KEY (building_id) REFERENCES building_instances(building_id) ON DELETE CASCADE,
    INDEX idx_player (player_id),
    INDEX idx_building (building_id)
);

-- Animal instances table (future)
CREATE TABLE animal_instances (
    animal_id VARCHAR(36) PRIMARY KEY,
    animal_type VARCHAR(255) NOT NULL,
    building_id VARCHAR(36),
    gender ENUM('MALE', 'FEMALE') NOT NULL,
    age INT DEFAULT 0,
    health DECIMAL(5,2) DEFAULT 100.00,
    satisfaction DECIMAL(5,2) DEFAULT 50.00,
    state ENUM('ALIVE', 'SICK', 'PREGNANT', 'DEAD') DEFAULT 'ALIVE',
    FOREIGN KEY (building_id) REFERENCES building_instances(building_id) ON DELETE SET NULL
);

-- Game state snapshots (for save/load)
CREATE TABLE game_saves (
    save_id VARCHAR(36) PRIMARY KEY,
    save_name VARCHAR(255) NOT NULL,
    game_turn INT NOT NULL,
    save_data JSON NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## Appendix C: Logging Configuration

### logback.xml
```xml
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/game.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/game.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <logger name="com.productionchain" level="DEBUG"/>

    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

---

**END OF IMPLEMENTATION PLAN v1.1.x**
