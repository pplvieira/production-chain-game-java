 
# Implementation Plan: v1.0

## Version Information
- **Target Version**: v1.0.x-milestone1
- **Planning Date**:
- **Target Release Date**:
- **Developer(s)**: Pedro & Claude
- **Status**: **Planning** / In Progress / Completed

---

## Overview
The idea with this game is to implement a super advanced micromanagement production and trading game in a medieval setting. Implementing super realistic mechanics like 
- a realistic, detailed, and historically accurate resource production trees, 
- a labor system where workers spend their working hours executing tasks like recipes in production buildings, tending to animals and buildings maintenance, household chores, and transporting of goods
- a free market governed by free trade between player lords and NPCs, where players can exchange goods at monetary or other goods prices set by the every-shifting market
- a very technical, statistical and analytical approach to solving problems and taking decisions
- a weather system and realistic interactions where real world events are simulated and influence mechanics in the gameplay
The idea is to also treat labor hours, money (gold) and some other special resources almost just like every other item. These all can be exchanged, used in recipes and traded equally.


## Instructions to Claude
I want your help to read this document, my handwritten requirements, and populate the rest of the template with your implementation, testing and deployment plan. I want you to check all the documentation under docs, understand what has already been implemented, and develop the implementation plan for the next steps



### Release Goals
<!-- Describe the main objectives and goals for this version -->

#### Code refactoring
- Code refactoring to fit the industry standard for java maven game projects
- Don't delete obsolete code but make it inaccessible for other parts of the code
- Follow docs/architecture/CODEBASE_ANALYSIS.md for guidance and to understand all the work i did alone and want i want to preserve
- It is very important for me that the game is built step by step with a lot of care and tests for the staple/backend classes, and making them future proof and testing each implementation thoroughly as we go so that there are no weak points along the way
- Dont make any changes in the main functions in each class. They are for self contained tests
- Under that CODEBASE_ANALYSIS file, in point 3.2, there is a list of critical issues. I will tell you what to do in relation to each of the issues
  - A - dont delete any of the code, just make it inaccessible to the rest of the codebase
  - B - remove the hardcoded references and make them such that they will work on any machine
  - C - make the registries with the proper definition. Remember that registries should essentially be read only,nd defined statically and publicly for everything else to see
  - D - implement proper test directories and one testing file for each major version. create a proper test suite but dont remove the main() tests
  - E - we will finish implementing these soon
- Proper organization and separation of code components. Separate staple/basic classes from registries from


#### Proper testing architecture
- Proper separated testing functions, to test incorporations of components from multiple classes to test the moving parts and serialization, reading and writing to jsons. As was mentioned above.


#### Features and mechanics
- **AdvancedStorage class** - this should implement a storage module that building instances use. This stores solid items in storage, executing the items' degradation in storage as turns pass
  - Allow multiple "bundles" of the same item to be in a single AdvancedStorage instance, each with different stages of decomposition
  - AdvancedStorages also have a list of allowed categories of items inside via a whitelist and a blacklist. If both are empty, allow anything inside. If the whitelist is not empty, allow only items from those categories. And block any item from the blacklisted categories. 
  - Check if an item wanting to be added belongs to any of the allowed categories before actually trying to add it to the storage
  - Include a degradationRateModifier for each AdvancedStorage instant. Which is essentially a dictionary of categories allowed inside the storage and the corresponding degradation rate modifier. Item categories omitted here are counted as having a multiplier of 1.0. (This is essentially to simulate stuff like freezers where food items are degraded slower than in the wild but stuff like wood would degrade just the same.)
  - Every turn, you should degrade every bundle of a resource separately, following the respective multiplier and degradation rate
  - Include a proper way to initialize the white and blacklists as well as the rate modifiers for the corresponding building type 
  - Building instances implement a AdvancedStorage, no matter the type of building instance
  - Make sure items that are added in the storage with different levels of degradation are added in the correct order in the queue

- **AdvancedFluidStorage** SKIP FOR NOW
  - Implement a new class like AdvancedStorage that buildings also use to store fluids, in a series of separate containers.

- **Recipe system**
  - Properly implement the recipes system
  - recipes have inputs, outputs, number of turns they take to be complete, the amount of labor hours they need, and allowed buildings
  - Building instances track active recipe, the number of turns left in the recipe, the amount of each resource and labor that has been put into it, tracks storage and starts and progresses recipes each turn.
  - Implement Realistic turn update in building instances, with recipes happening and items in storage degrading 
  - **State change recipes** - recipes that have inputs but the outputs are some form of function that changes the internal state of the buildings they are being run in. Like changing the degrading condition of the building by repairing it, or adding an upgrade to the building instance. Implement these properly as well


- **Animal modelling - animal, buildings** - continue with the partial implementation
  - Animal buildings can hold a number of a specific category of animals in some condition
  - They require food, water, care and possible medication
  - **Animal modelling** - each animal instance in a animal building is modeled individually but the user is only presented with a more overview statistical data and distributions of the animal's conditions. If they chose they can track individual animals. Players can chose to buy, sell, kill animals at different stages, and chose the individual animal to apply that action to.

- **Player class** - create new class
  - Players have money and other informations for now.
  - But essentially i want players to *possess* building instances around the map.
  - Help me plan what "players" should have

- **Add more entries in the registries**
  - Add a few farming or milling recipes in the registries to test a simple production chain with a few buildings, storages and recipes running over a few turns.


### Key Features
<!-- List the major features to be implemented -->
- Code refactor
- Proper testing suite 
- Proper implementation of AdvancedStorage class
- Proper implementation of all current building types and building instances (production storage and animal)
- Proper implementation of animal mechanics, statistics and building-level management



### Success Criteria
<!-- Define what success looks like for this release -->
- Testing of all components, reading and writing to jsons with no missing information
- Implement a few experimental items, buildings, animals and recipes for the registries
- â€¦
-

---

## Phase 1: Cleanup & Refactoring

### Tasks
- [ ]
- [ ]
- [ ]

### Estimated Time
<!-- e.g., 2-3 days -->

### Dependencies
<!-- Any prerequisites or blockers -->

---

## Phase 2: Core Development

### Tasks
- [ ]
- [ ]
- [ ]

### Estimated Time
<!-- e.g., 1-2 weeks -->

### Dependencies
<!-- Any prerequisites or blockers -->

---

## Phase 3: Testing & Quality Assurance

### Tasks
- [ ]
- [ ]
- [ ]

### Estimated Time
<!-- e.g., 3-5 days -->

### Dependencies
<!-- Any prerequisites or blockers -->

---

## Phase 4: Documentation & Polish

### Tasks
- [ ]
- [ ]
- [ ]

### Estimated Time
<!-- e.g., 2-3 days -->

### Dependencies
<!-- Any prerequisites or blockers -->

---

## Technical Specifications

### Architecture Changes
<!-- Describe any architectural changes or additions -->

### New Components
<!-- List new classes, packages, or modules -->
-
-
-

### Modified Components
<!-- List existing components that will be modified -->
-
-
-

### Dependencies
<!-- New libraries or tools required -->
-
-

---

## Testing Strategy

### Unit Tests
<!-- Describe unit testing approach -->

### Integration Tests
<!-- Describe integration testing approach -->

### Manual Testing Checklist
- [ ]
- [ ]
- [ ]

---

## Known Issues & Risks

### Technical Risks
<!-- Identify potential technical challenges -->
-
-

### Mitigation Strategies
<!-- How to address the risks -->
-
-

---

## Timeline

| Phase | Start Date | End Date | Status |
|-------|------------|----------|--------|
| Phase 1: Cleanup | | | |
| Phase 2: Core Development | | | |
| Phase 3: Testing | | | |
| Phase 4: Documentation | | | |

---

## Notes & Decisions

### Design Decisions
<!-- Document important design decisions made during development -->

### Changes from Original Plan
<!-- Track deviations from the initial plan -->

### Lessons Learned
<!-- Post-implementation reflections -->

---

## Related Documentation
- [Important all purpose development documentation](../README.md)
- [Architecture Documentation](../architecture/)
- [Codebase Analysis](../architecture/CODEBASE_ANALYSIS.md)
- [Deployment Guide](../deployment/)
